# =========================================================
# MEN batch network plot (1.txt ~ 76.txt)
# each file: rows=taxa, cols=samples(8), value=RPKM
#
# Outputs:
#   out/networks/net_001.png ... net_076.png
#   out/networks/networks_2x4.png (optional montage)
#
# Author: generated by ChatGPT
# =========================================================

suppressPackageStartupMessages({
  library(tidyverse)
  library(Hmisc)      # rcorr
  library(igraph)
  library(ggraph)
  library(ggforce)    # geom_mark_hull
  library(patchwork)  # montage
  library(scales)
})

# -----------------------------
# 用户可调参数
# -----------------------------
IN_DIR  <- "."                 # 1.txt ~ 76.txt 所在目录
OUT_DIR <- "out/networks"      # 输出目录
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)

files <- sprintf("%d.txt", 1:76)   # 默认 1.txt~76.txt
files <- file.path(IN_DIR, files)

# persistence：保留在 >= pers.cutoff * Nsample 的样本中出现(>0)的物种
pers.cutoff <- 0.10

# 相关阈值（建议先用 0.6；8个样本很少，网络稳定性一般）
r.cut  <- 0.60
p.cut  <- 0.05
p.adjust.method <- "BH"   # BH 或 none

# 节点大小：按 mean RPKM（log10）或 degree
node_size_mode <- "abundance"  # "abundance" / "degree"

# 社区划分方法
community_method <- "louvain"  # "louvain" / "walktrap"

# 输出图片参数
png_w <- 1400
png_h <- 1200
png_dpi <- 200

# 温度标签映射（可选）
# 准备一个 csv：两列 file,temp，例如:
# file,temp
# 1,28.06
# 2,31.81
# ...
TEMP_MAP_CSV <- NULL  # 例如 "file_to_temp.csv"


# -----------------------------
# 工具函数
# -----------------------------
read_one <- function(path){
  x <- read.table(path, header = TRUE, row.names = 1, sep = "\t",
                  quote = "", check.names = FALSE, comment.char = "")
  x <- as.matrix(x)
  storage.mode(x) <- "numeric"
  x
}

persistence_filter <- function(mat, pers.cutoff){
  # mat: taxa x samples
  ns <- ncol(mat)
  min_pres <- ceiling(pers.cutoff * ns)
  keep <- rowSums(mat > 0, na.rm = TRUE) >= min_pres
  mat[keep, , drop = FALSE]
}

build_network <- function(mat_taxa_sample, r.cut, p.cut, p.adjust.method,
                          community_method = "louvain"){
  # 输入：taxa x samples
  mat <- mat_taxa_sample
  if(nrow(mat) < 3) return(NULL)
  
  # 对相关更稳一点：log1p（可按你习惯改）
  mat2 <- log1p(mat)
  
  # 相关：taxa-taxa，需要 samples x taxa
  dat <- t(mat2)  # samples x taxa
  rc <- Hmisc::rcorr(dat, type = "spearman")
  r  <- rc$r
  p  <- rc$P
  
  # p.adjust
  if(p.adjust.method != "none"){
    upper_idx <- upper.tri(p, diag = FALSE)
    p_adj_vec <- p.adjust(p[upper_idx], method = p.adjust.method)
    p_adj <- matrix(1, nrow(p), ncol(p), dimnames = dimnames(p))
    p_adj[upper_idx] <- p_adj_vec
    p_adj <- t(p_adj)
    p_adj[upper_idx] <- p_adj_vec
    diag(p_adj) <- 0
    p_use <- p_adj
  } else {
    p_use <- p
  }
  
  # 筛边
  keep_edge <- (abs(r) >= r.cut) & (p_use <= p.cut)
  diag(keep_edge) <- FALSE
  
  # 构建邻接矩阵（权重=r）
  adj <- r
  adj[!keep_edge] <- 0
  diag(adj) <- 0
  
  # 如果几乎没边，返回 NULL
  if(sum(adj != 0) < 2) return(NULL)
  
  g <- igraph::graph_from_adjacency_matrix(
    adj, mode = "undirected", weighted = TRUE, diag = FALSE
  )
  g <- igraph::simplify(g, remove.multiple = TRUE, remove.loops = TRUE)
  
  # 去掉孤点（可选；不去也行）
  g <- igraph::delete.vertices(g, which(igraph::degree(g) == 0))
  if(igraph::vcount(g) < 3) return(NULL)
  
  # 社区划分（基于 |weight|）
  E(g)$absw <- abs(E(g)$weight)
  com <- switch(
    community_method,
    "walktrap" = igraph::cluster_walktrap(g, weights = E(g)$absw),
    "louvain"  = igraph::cluster_louvain(g, weights = E(g)$absw),
    igraph::cluster_louvain(g, weights = E(g)$absw)
  )
  V(g)$module <- as.factor(igraph::membership(com))
  
  list(g = g, r = r, p = p_use)
}

plot_network <- function(gobj, mat_taxa_sample, label_text = NULL,
                         node_size_mode = "abundance"){
  g <- gobj$g
  taxa <- V(g)$name
  
  # 节点大小
  if(node_size_mode == "abundance"){
    mean_ab <- rowMeans(mat_taxa_sample[taxa, , drop = FALSE], na.rm = TRUE)
    V(g)$size_val <- rescale(log10(mean_ab + 1e-8), to = c(2, 10))
  } else {
    V(g)$size_val <- rescale(igraph::degree(g), to = c(2, 10))
  }
  
  # 边颜色：同模块用模块色，不同模块灰
  edge_df <- igraph::as_data_frame(g, what = "edges") %>%
    mutate(
      mod_from = V(g)$module[match(from, V(g)$name)],
      mod_to   = V(g)$module[match(to,   V(g)$name)],
      same_mod = (mod_from == mod_to),
      mod_edge = ifelse(same_mod, as.character(mod_from), "between"),
      w_abs    = abs(weight)
    )
  
  # 将 edge_df 写回 ggraph 用：用 igraph 直接画时可在 aes 中引用 edge_*
  # 这里用 ggraph 的 edge aesthetics: edge_width, edge_alpha, edge_colour
  # 用一个手动调色：模块自动用 hue，between 用灰
  mods <- levels(V(g)$module)
  pal <- hue_pal()(length(mods))
  names(pal) <- mods
  
  edge_colors <- c(pal, between = "grey70")
  
  p <- ggraph(g, layout = "fr") +
    # 模块 hull（包络）
    ggforce::geom_mark_hull(
      aes(x = x, y = y, group = module, fill = module),
      expand = unit(2, "mm"),
      concavity = 3,
      alpha = 0.25,
      color = NA
    ) +
    # 边
    geom_edge_link(
      aes(
        edge_width = abs(weight),
        edge_alpha = abs(weight),
        edge_colour = after_stat(
          ifelse(
            igraph::as_data_frame(g, what="edges")$from %in% character(0),
            "between","between"
          )
        )
      ),
      show.legend = FALSE
    ) +
    # 用 edge_df 来更精确控制颜色：改用 ggraph::get_edges() 合并
    # 简化起见下面用 geom_edge_link0 + edge_df 映射
    NULL
  
  # 更稳的方式：用 ggraph::get_edges() 拿到边表再映射
  ed <- ggraph::get_edges(p)
  # ed 含 from/to + x/y，补上模块信息
  ed2 <- ed %>%
    mutate(
      mod_from = V(g)$module[match(from, V(g)$name)],
      mod_to   = V(g)$module[match(to,   V(g)$name)],
      mod_edge = ifelse(mod_from == mod_to, as.character(mod_from), "between"),
      w_abs = abs(weight)
    )
  
  # 重新画（覆盖上面那段）
  p <- ggraph(g, layout = "fr") +
    ggforce::geom_mark_hull(
      aes(x = x, y = y, group = module, fill = module),
      expand = unit(2, "mm"),
      concavity = 3,
      alpha = 0.25,
      color = NA
    ) +
    geom_edge_link(
      data = ed2,
      aes(x = x, y = y, xend = xend, yend = yend,
          edge_width = w_abs,
          edge_alpha = w_abs,
          edge_colour = mod_edge),
      lineend = "round",
      show.legend = FALSE
    ) +
    geom_node_point(aes(size = size_val, colour = module), alpha = 0.95) +
    theme_void(base_size = 11) +
    scale_edge_width(range = c(0.2, 1.2)) +
    scale_edge_alpha(range = c(0.15, 0.85)) +
    scale_colour_manual(values = pal) +
    scale_fill_manual(values = pal) +
    guides(size = "none") +
    coord_equal()
  
  if(!is.null(label_text)){
    p <- p + annotate("text", x = -Inf, y = -Inf,
                      label = label_text,
                      hjust = -0.05, vjust = -0.8, size = 4)
  }
  
  p
}

# -----------------------------
# 温度映射（可选）
# -----------------------------
temp_map <- NULL
if(!is.null(TEMP_MAP_CSV)){
  temp_map <- read.csv(TEMP_MAP_CSV, stringsAsFactors = FALSE)
  # 期望：file,temp；file 是 1..76
  if(!all(c("file","temp") %in% colnames(temp_map))){
    stop("TEMP_MAP_CSV must have columns: file,temp")
  }
}

label_for_file <- function(i){
  if(!is.null(temp_map)){
    tt <- temp_map$temp[temp_map$file == i]
    if(length(tt) == 1 && !is.na(tt)) return(sprintf("%.2f°C", tt))
  }
  sprintf("File %02d", i)
}

# -----------------------------
# 主循环：生成 76 个网络图
# -----------------------------
plots <- vector("list", length(files))

for(i in seq_along(files)){
  f <- files[i]
  if(!file.exists(f)){
    message("[Skip] not found: ", f)
    next
  }
  
  mat <- read_one(f)                 # taxa x samples
  mat <- mat[rowSums(mat) > 0, , drop = FALSE]
  mat <- persistence_filter(mat, pers.cutoff)
  
  if(nrow(mat) < 3){
    message("[Skip] too few taxa after filter: ", basename(f))
    next
  }
  
  gobj <- build_network(mat, r.cut, p.cut, p.adjust.method, community_method)
  if(is.null(gobj)){
    message("[Skip] no network edges: ", basename(f))
    next
  }
  
  lab <- label_for_file(i)
  p <- plot_network(gobj, mat, label_text = lab, node_size_mode = node_size_mode)
  
  out_png <- file.path(OUT_DIR, sprintf("net_%03d.png", i))
  ggsave(out_png, p, width = png_w/100, height = png_h/100, dpi = png_dpi)
  plots[[i]] <- p
  
  message("[OK] ", basename(f), " -> ", out_png)
}

# -----------------------------
# 额外：拼一个 2×4 的总图（你自己指定 8 个文件号）
# -----------------------------
# 例子：选 8 个文件号（按你的温度关键点改）
selected <- c(1, 10, 20, 30, 40, 50, 60, 76)

sel_plots <- plots[selected]
# 去掉空的
sel_plots <- sel_plots[!sapply(sel_plots, is.null)]

if(length(sel_plots) > 0){
  big <- wrap_plots(sel_plots, ncol = 4)
  ggsave(file.path(OUT_DIR, "networks_2x4.png"),
         big, width = 16, height = 8, dpi = 200)
}
